# Linkling

Link程序如何与特定系统软件交互

  各种.c 文件c 调用 预处理器preprocessor(cpp)->编译器cc1->汇编器as->各种.o

最后通过连接器linker组合形成**完全连接可执行目标文件**

## 这样做目的

1. 模块化
2. 效率高，不需要重编译没有修改的模块

## 怎么做的

1. 符号解析（变量命，函数名，引用，当我们调用变量或者函数就会找到指向他们的symbol，即符号引用），所有symbol保存在一个结构体数组里面，将**symbol reference符号引用**与一个**symbol definition(符号定义)**相关联  ,**就可在重定位时`将引用符号的地址重定位为相关联的定义符号的地址`。符号解析也称符号绑定**   

    (符号引用举个例子就是main()里调用的方法，和赋值和接受值的变量)

   ------

   **Q：“符号的定义实质是什么？**
   **A：*指被*分配了存储空间**。为函数名即指其代码所在区；为变量名即指其所占的静态数据区。

   **所有`定义符号的值`就是其目标所在的`首地址`**

   ------

   

1.  relocation，1 将所有模块合并到一个可执行的目标模块中，可以在系统上直接执行，2 并确定每个**symbol**在内存的位置，位置和symbol绑定在一起，更新每个符号的引用的位置。

## 各种目标文件

 xx.o: relocatable object file,用来和别的 .o文件合并

a.out: 可执行文件

xx.so:    共享object

## 打包公共的常用方法

1. 把所有方法放到一个文件

2. 把每个方法放到不同的源文件(麻烦的是程序必须直到所有这些函数的位置并将他们放在make文件中，使得GCC命令很长)

   

为了解决上面提出静态库，c语言文件通过translator生成.o 文件，再汇聚成archiver文件，这就是libc.a

现在解决方案是使用动态库或者共享库，通过共享对象，解决使用静态库的方法，都必须复制一个副本的问题，

对共享库对象的引用linking操作被推迟到程序(可执行文件)实际加载到内存中(.dll .so)



